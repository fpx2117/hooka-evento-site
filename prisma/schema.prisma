// ========================================================
// Prisma Schema â€” Entradas Generales y VIP (por ubicaciÃ³n)
// DB: PostgreSQL
// ========================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================= Enums =========================

enum PaymentStatus {
  pending
  approved
  rejected
  in_process
  failed_preference
  cancelled
  refunded
  charged_back
}

enum PaymentMethod {
  mercadopago
  transferencia
  efectivo
}

enum DiscountType {
  percent // porcentaje (ej: 10 = 10%)
  amount // monto fijo (ej: 500)
}

enum Gender {
  hombre
  mujer
}

enum TableLocation {
  piscina
  dj
  general
}

enum TicketType {
  general
  vip
}

// Motivo por el que un ticket pasa a histÃ³rico/archivo
enum ArchiveReason {
  user_deleted
  admin_cancelled
  payment_timeout
  refunded
  charged_back
  other
}

// ========================= Admin =========================

model Admin {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String
  name      String
  createdAt DateTime @default(now())

  @@index([username])
}

// ========================= Evento =========================

model Event {
  id       String   @id @default(cuid())
  code     String   @unique
  name     String
  date     DateTime
  isActive Boolean  @default(true)

  ticketConfig TicketConfig[]
  vipConfigs   VipTableConfig[]

  tickets       Ticket[]
  discountRules DiscountRule[]

  // ðŸ”™ back-relation hacia los archivos
  ticketArchives TicketArchive[] @relation("Event_TicketArchive")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ========================= Ticket (ACTIVO) =========================
// - GENERAL: quantity = personas, gender = hombre|mujer
// - VIP:     vipLocation + vipTables + capacityPerTable + tableNumber

model Ticket {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  ticketType TicketType
  gender     Gender? // sÃ³lo en general
  quantity   Int        @default(1) // personas (sÃ³lo general)

  // VIP (por ubicaciÃ³n, en mesas)
  vipLocation      TableLocation?
  vipTables        Int? // mesas compradas (VIP)
  capacityPerTable Int? // personas por mesa (VIP)
  tableNumber      Int? // nÃºmero de mesa especÃ­fica

  totalPrice Decimal @db.Decimal(10, 2)

  customerName  String
  customerEmail String
  customerPhone String
  customerDni   String

  paymentId     String?       @unique
  paymentStatus PaymentStatus @default(pending)
  paymentMethod PaymentMethod @default(mercadopago)

  qrCode         String?   @unique
  validationCode String?   @unique
  validated      Boolean   @default(false)
  validatedAt    DateTime?

  purchaseDate DateTime  @default(now())
  eventDate    DateTime?
  expiresAt    DateTime?

  ticketConfigId String?
  ticketConfig   TicketConfig? @relation(fields: [ticketConfigId], references: [id], onDelete: SetNull)

  emailSentAt DateTime?

  // ðŸ”™ back-relation: un Ticket puede tener muchos archivos derivados
  archives TicketArchive[] @relation("Ticket_ArchivedFrom")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eventId])
  @@index([customerEmail])
  @@index([customerDni])
  @@index([paymentId])
  @@index([paymentStatus, purchaseDate])
  @@index([ticketType, gender])
  @@index([emailSentAt])
  @@index([vipLocation])
  @@index([tableNumber])
}

// ========================= TicketArchive (HISTÃ“RICO) =========================
// Copia de Ticket + metadatos de archivo. NOTA: aquÃ­ NO usamos unique en
// paymentId/qrCode/validationCode para permitir conservar duplicados histÃ³ricos.

model TicketArchive {
  id String @id @default(cuid())

  // referencia al Ticket original (si proviene de uno activo)
  archivedFromId String?
  archivedFrom   Ticket? @relation("Ticket_ArchivedFrom", fields: [archivedFromId], references: [id], onDelete: SetNull)

  eventId String
  event   Event  @relation("Event_TicketArchive", fields: [eventId], references: [id], onDelete: Cascade)

  ticketType TicketType
  gender     Gender?
  quantity   Int        @default(1)

  vipLocation      TableLocation?
  vipTables        Int?
  capacityPerTable Int?
  tableNumber      Int?

  totalPrice Decimal @db.Decimal(10, 2)

  customerName  String
  customerEmail String
  customerPhone String
  customerDni   String

  paymentId     String?
  paymentStatus PaymentStatus @default(pending)
  paymentMethod PaymentMethod @default(mercadopago)

  qrCode         String?
  validationCode String?
  validated      Boolean   @default(false)
  validatedAt    DateTime?

  purchaseDate DateTime  @default(now())
  eventDate    DateTime?
  expiresAt    DateTime?

  ticketConfigId String?
  ticketConfig   TicketConfig? @relation("TicketConfig_TicketArchive", fields: [ticketConfigId], references: [id], onDelete: SetNull)

  emailSentAt DateTime?

  // Metadatos de archivo
  archivedAt    DateTime      @default(now())
  archivedBy    String?
  archiveReason ArchiveReason @default(other)
  archiveNotes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eventId])
  @@index([customerEmail])
  @@index([customerDni])
  @@index([paymentId])
  @@index([paymentStatus, purchaseDate])
  @@index([ticketType, gender])
  @@index([emailSentAt])
  @@index([vipLocation])
  @@index([tableNumber])
}

// ========================= Reglas de descuento =========================

model DiscountRule {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  ticketType String
  gender     Gender?

  minQty   Int
  type     DiscountType
  value    Decimal      @db.Decimal(10, 2)
  isActive Boolean      @default(true)
  priority Int          @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, ticketType, gender, minQty])
  @@index([eventId, ticketType, gender, isActive])
}

// ========================= ConfiguraciÃ³n de ENTRADAS =========================

model TicketConfig {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  ticketType String
  gender     Gender?

  price      Decimal @db.Decimal(10, 2)
  stockLimit Int     @default(0)
  soldCount  Int     @default(0)

  tickets Ticket[]

  // ðŸ”™ back-relation: archivos asociados a esta config
  archives TicketArchive[] @relation("TicketConfig_TicketArchive")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, ticketType, gender], name: "eventId_ticketType_gender")
  @@index([eventId, ticketType, gender])
  @@index([eventId])
  @@index([ticketType])
}

// ========================= ConfiguraciÃ³n MESAS VIP =========================

model VipTableConfig {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  location TableLocation
  price    Decimal       @db.Decimal(10, 2)

  stockLimit       Int
  soldCount        Int @default(0)
  capacityPerTable Int @default(10)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, location])
  @@index([eventId, location])
}
