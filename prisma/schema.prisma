generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================= Enums =========================
enum PaymentStatus {
  pending
  approved
  rejected
  in_process
  failed_preference
  cancelled
  refunded
  charged_back
}

enum PaymentMethod {
  mercadopago
  transferencia
  efectivo
}

enum DiscountType {
  percent // porcentaje (ej: 10 = 10%)
  amount  // monto fijo por entrada (ej: 500)
}

enum Gender {
  hombre
  mujer
}

// Ubicaciones administrables para mesas VIP
enum TableLocation {
  piscina
  dj
  general
}

// ========================= Admin =========================
model Admin {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String
  name      String
  createdAt DateTime @default(now())

  @@index([username])
}

// ========================= Evento =========================
model Event {
  id           String           @id @default(cuid())
  code         String           @unique
  name         String
  date         DateTime
  isActive     Boolean          @default(true)

  ticketConfig TicketConfig[]
  vipConfigs   VipTableConfig[]

  tickets      Ticket[]
  tableRes     TableReservation[]

  // 👇 Lado inverso para DiscountRule
  discountRules DiscountRule[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

// ========================= Tickets =========================
// ticketType: "general" | "vip"
// VIP no tiene género (gender = null)
model Ticket {
  id             String         @id @default(cuid())
  eventId        String
  event          Event          @relation(fields: [eventId], references: [id])

  ticketType     String
  gender         Gender?
  quantity       Int            @default(1)

  // Dinero como Decimal
  totalPrice     Decimal        @db.Decimal(10, 2)

  customerName   String
  customerEmail  String
  customerPhone  String
  customerDni    String

  paymentId      String?        @unique
  paymentStatus  PaymentStatus  @default(pending)
  paymentMethod  PaymentMethod  @default(mercadopago)

  qrCode         String?        @unique
  validationCode String?        @unique
  validated      Boolean        @default(false)
  validatedAt    DateTime?
  purchaseDate   DateTime       @default(now())
  eventDate      DateTime?
  expiresAt      DateTime?

  // Para trazar contra qué config descontó stock/precio
  ticketConfigId String?
  ticketConfig   TicketConfig?  @relation(fields: [ticketConfigId], references: [id])

  // === NUEVO: marca de idempotencia de email enviado ===
  emailSentAt    DateTime?      // se setea cuando se envía el correo de confirmación

  @@index([eventId])
  @@index([customerEmail])
  @@index([paymentId])
  @@index([customerDni])
  @@index([paymentStatus, purchaseDate])
  @@index([ticketType, gender])
  @@index([emailSentAt])        // opcional, recomendado
}

// ========================= Reservas de Mesa VIP =========================
// "tables" = cantidad de mesas en la operación
// Para stock total de personas VIP: tables * capacityPerTable (de VipTableConfig)
model TableReservation {
  id               String         @id @default(cuid())
  eventId          String
  event            Event          @relation(fields: [eventId], references: [id])

  packageType      String
  location         TableLocation

  tables           Int            @default(1)
  capacity         Int
  guests           Int

  totalPrice       Decimal        @db.Decimal(10, 2)

  customerName     String
  customerEmail    String
  customerPhone    String
  customerDni      String
  reservationDate  DateTime

  paymentId        String?        @unique
  paymentStatus    PaymentStatus  @default(pending)
  paymentMethod    PaymentMethod  @default(mercadopago)

  qrCode           String?        @unique
  validationCode   String?        @unique
  validated        Boolean        @default(false)
  validatedAt      DateTime?
  createdAt        DateTime       @default(now())
  expiresAt        DateTime?

  vipTableConfigId String?
  vipTableConfig   VipTableConfig? @relation(fields: [vipTableConfigId], references: [id])

  // === NUEVO: marca de idempotencia de email enviado ===
  emailSentAt      DateTime?      // se setea cuando se envía el correo de confirmación

  @@index([eventId])
  @@index([customerEmail])
  @@index([paymentId])
  @@index([reservationDate])
  @@index([customerDni])
  @@index([paymentStatus, reservationDate])
  @@index([location, reservationDate])
  @@index([emailSentAt])          // opcional, recomendado
}

// ========================= Reglas de descuento por cantidad =========================
model DiscountRule {
  id        String        @id @default(cuid())
  eventId   String
  event     Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  ticketType String       // "general" | "vip"
  gender     Gender?      // "hombre" | "mujer" | null (VIP: null)

  minQty    Int           // cantidad mínima para que aplique
  type      DiscountType
  value     Decimal       @db.Decimal(10, 2)
  isActive  Boolean       @default(true)
  priority  Int           @default(0) // para resolver empates

  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([eventId, ticketType, gender, minQty])
  @@index([eventId, ticketType, gender, isActive])
}

// ========================= Configuración de ENTRADAS =========================
// Filas típicas por evento:
// - (ticketType="general", gender="hombre")
// - (ticketType="general", gender="mujer")
// - (ticketType="vip",     gender=null)  -> VIP expresado en PERSONAS totales
// - (ticketType="total",   gender=null)  -> cupo TOTAL (personas) del evento
model TicketConfig {
  id         String        @id @default(cuid())
  event      Event         @relation(fields: [eventId], references: [id])
  eventId    String

  ticketType String
  gender     Gender?

  price      Decimal       @db.Decimal(10, 2)
  stockLimit Int           @default(0)
  soldCount  Int           @default(0)

  // Lado inverso de Ticket.ticketConfig
  tickets    Ticket[]

  @@unique([eventId, ticketType, gender], name: "eventId_ticketType_gender")
  @@index([eventId, ticketType, gender])
}

// ========================= Configuración de MESAS VIP por ubicación =========================
// stockLimit = cantidad de MESAS permitidas en esa ubicación
// capacityPerTable por defecto 10 (1 mesa = 10 personas)
model VipTableConfig {
  id               String        @id @default(cuid())
  eventId          String
  event            Event         @relation(fields: [eventId], references: [id])

  location         TableLocation
  price            Decimal       @db.Decimal(10, 2)

  stockLimit       Int
  soldCount        Int           @default(0)
  capacityPerTable Int           @default(10)

  tableRes         TableReservation[]

  @@unique([eventId, location])
  @@index([eventId, location])
}
