generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Admin {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String
  name      String
  createdAt DateTime @default(now())

  @@index([username])
}

model Event {
  id             String           @id @default(cuid())
  code           String           @unique
  name           String
  date           DateTime
  isActive       Boolean          @default(true)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  discountRules  DiscountRule[]
  tickets        Ticket[]
  ticketArchives TicketArchive[]  @relation("Event_TicketArchive")
  ticketConfigs  TicketConfig[]
  vipConfigs     VipTableConfig[]
}

model VipTableConfig {
  id               String        @id @default(cuid())
  eventId          String
  location         TableLocation
  price            Decimal       @db.Decimal(10, 2)
  stockLimit       Int
  soldCount        Int           @default(0)
  capacityPerTable Int           @default(10)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  event            Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, location])
  @@index([eventId, location])
}

model Ticket {
  id               String          @id @default(cuid())
  quantity         Int             @default(1)
  totalPrice       Decimal         @db.Decimal(10, 2)
  customerName     String
  customerEmail    String
  customerPhone    String
  customerDni      String
  gender           Gender?
  paymentId        String?         @unique
  paymentStatus    PaymentStatus   @default(pending)
  paymentMethod    PaymentMethod   @default(mercadopago)
  qrCode           String?         @unique
  validationCode   String?         @unique
  validated        Boolean         @default(false)
  validatedAt      DateTime?
  purchaseDate     DateTime        @default(now())
  eventDate        DateTime?
  eventId          String
  expiresAt        DateTime?
  ticketConfigId   String?
  emailSentAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  ticketType       TicketType
  capacityPerTable Int?
  vipLocation      TableLocation?
  vipTables        Int?
  tableNumber      Int?
  event            Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  ticketConfig     TicketConfig?   @relation(fields: [ticketConfigId], references: [id])
  archives         TicketArchive[] @relation("Ticket_ArchivedFrom")

  @@index([eventId])
  @@index([paymentId])
  @@index([paymentStatus, purchaseDate])
  @@index([ticketType, gender])
  @@index([customerDni])
  @@index([customerEmail])
  @@index([emailSentAt])
  @@index([tableNumber])
  @@index([vipLocation])
}

model TicketArchive {
  id               String         @id @default(cuid())
  archivedFromId   String?
  eventId          String
  ticketType       TicketType
  gender           Gender?
  quantity         Int            @default(1)
  vipLocation      TableLocation?
  vipTables        Int?
  capacityPerTable Int?
  tableNumber      Int?
  totalPrice       Decimal        @db.Decimal(10, 2)
  customerName     String
  customerEmail    String
  customerPhone    String
  customerDni      String
  paymentId        String?
  paymentStatus    PaymentStatus  @default(pending)
  paymentMethod    PaymentMethod  @default(mercadopago)
  qrCode           String?
  validationCode   String?
  validated        Boolean        @default(false)
  validatedAt      DateTime?
  purchaseDate     DateTime       @default(now())
  eventDate        DateTime?
  expiresAt        DateTime?
  ticketConfigId   String?
  emailSentAt      DateTime?
  archivedAt       DateTime       @default(now())
  archivedBy       String?
  archiveReason    ArchiveReason  @default(other)
  archiveNotes     String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  archivedFrom     Ticket?        @relation("Ticket_ArchivedFrom", fields: [archivedFromId], references: [id])
  event            Event          @relation("Event_TicketArchive", fields: [eventId], references: [id], onDelete: Cascade)
  ticketConfig     TicketConfig?  @relation("TicketConfig_TicketArchive", fields: [ticketConfigId], references: [id])

  @@index([eventId])
  @@index([customerEmail])
  @@index([customerDni])
  @@index([emailSentAt])
  @@index([paymentId])
  @@index([paymentStatus, purchaseDate])
  @@index([tableNumber])
  @@index([ticketType, gender])
  @@index([vipLocation])
}

model DiscountRule {
  id         String       @id @default(cuid())
  eventId    String
  ticketType String
  gender     Gender?
  minQty     Int
  type       DiscountType
  value      Decimal      @db.Decimal(10, 2)
  isActive   Boolean      @default(true)
  priority   Int          @default(0)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  event      Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, ticketType, gender, minQty])
  @@index([eventId, ticketType, gender, isActive])
}

model TicketConfig {
  id         String          @id @default(cuid())
  eventId    String
  ticketType String
  gender     Gender?
  price      Decimal         @db.Decimal(10, 2)
  stockLimit Int             @default(0)
  soldCount  Int             @default(0)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  tickets    Ticket[]
  archives   TicketArchive[] @relation("TicketConfig_TicketArchive")
  event      Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, ticketType, gender])
  @@index([eventId, ticketType, gender])
  @@index([eventId])
  @@index([ticketType])
}

enum PaymentStatus {
  pending
  approved
  rejected
  in_process
  failed_preference
  cancelled
  refunded
  charged_back
}

enum PaymentMethod {
  mercadopago
  transferencia
  efectivo
}

enum DiscountType {
  percent
  amount
}

enum Gender {
  hombre
  mujer
}

enum TicketType {
  general
  vip
}

enum ArchiveReason {
  user_deleted
  admin_cancelled
  payment_timeout
  refunded
  charged_back
  other
}

enum TableLocation {
  piscina
  dj
  general
}
